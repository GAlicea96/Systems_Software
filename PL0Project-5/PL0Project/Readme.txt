Guillermo Alicea
PL/0 Compiler readme
07/24/2016

How to compile and run PL/0 compiler:

	1)Ensure that CompileDriver.c, LexicalAnalyzer.h, Parser.h, and VirtualMachine.h are in
	the same directory. On a unix-like terminal, such as Eustis, using gcc, enter the command
	"gcc CompileDriver.c" or "gcc CompileDriver.c -o <name for the executable>"

	2)Include a text file named "input.txt", which holds the sequence code that will
	be used as the input for the compiler. Include this in the directory of CompileDriver.c,
	the compiled executable, and the header files.

	3)There is currently one useable directive for the compiler - "-l". Adding this directive
	will print the list of lexemes to the list, whether or not a lexical or parsing error is encountered.
	Any other directive will simply be ignored, and compilation will proceed as normal.

	4)To run the compiler, use the command "./a.out" if no directive is used or "./a.out -l" if
	a directive is used. If you gave the executable your own name the commands become "./<name>"
	and "./<name> -l".

	5)Upon execution, the lexicalanalyzer will read the input file and produce lexemelist.txt,
	lexemetable.txt, cleaninput.txt, and parserinput.txt. parserinput.txt is used by the parser and may be ignored. The
	other three text files are representations of the list of lexemes, the table of lexemes, and the input stripped of comments, respectively.
	Next, if prompted by the use of a directive, the lexemelist will be printed to the screen. In the event of a lexical error*,
	this too will be printed to the screen and the compilation process will stop (no parsing or vm).

	In the case that no errors are encountered, the parser will begin - taking in parserinput.txt and generating
	symboltable.txt and mcode.txt. symboltable.txt is a representation of the symbol table created by the parser
	and mcode.txt is the assembly code generated by the code generation within the parser for use as input in the vm.
	At the parsing step, if an error* is encountered, the error will be printed to the screen and the parsing/code
	generation process will stop.

	Otherwise, the virtual machine is started and, using mcode.txt as input, will produce
	stacktrace.txt, which is a nice output of the assembly code and the corresponding stacktrace. At this point, no errors should
	be found in the mcode, so no printing to the screen will occur due to errors. However, be mindful that you may be prompted
	for input from stdin (keyboard) if your initial code had a read command, and likewise, a value may be printed
	to stdout (screen) if your initial code had a write command.

	All of this, the lexical analysis, parsing, and vm, are handled by the CompileDriver, which acts as the main driver or director
	for the compiler. It is also responsible for checking for any directives.

	---Example input and output of a factorial program (from hw1 test cases) is included as an example. input.txt contains the
	input program, while the output of running the program through the compiler is provided in each of their respective txt files.
	Any thing printed to the screen as a result of the execution, an example of compilation, and an example of execution, is provided in examplescreen.txt.

	*A list of errors checked for is provided in errorlist.txt (updated with paramter passing/return errors)
